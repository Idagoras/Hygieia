// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: eegsession.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const createEEGSession = `-- name: CreateEEGSession :exec
INSERT INTO ` + "`" + `eeg_session` + "`" + ` (
     uid,begin,end,data_count,expired_at
) VALUES (
    ?,?,?,?,?
)
`

type CreateEEGSessionParams struct {
	Uid       uint64    `json:"uid"`
	Begin     time.Time `json:"begin"`
	End       time.Time `json:"end"`
	DataCount uint32    `json:"data_count"`
	ExpiredAt time.Time `json:"expired_at"`
}

func (q *Queries) CreateEEGSession(ctx context.Context, arg CreateEEGSessionParams) error {
	_, err := q.db.ExecContext(ctx, createEEGSession,
		arg.Uid,
		arg.Begin,
		arg.End,
		arg.DataCount,
		arg.ExpiredAt,
	)
	return err
}

const getEEGSessionByID = `-- name: GetEEGSessionByID :one
SELECT id, uid, begin, end, data_count, expired_at, finish, data_bits_map FROM ` + "`" + `eeg_session` + "`" + ` WHERE id = ? LIMIT 1
`

func (q *Queries) GetEEGSessionByID(ctx context.Context, id uint64) (EegSession, error) {
	row := q.db.QueryRowContext(ctx, getEEGSessionByID, id)
	var i EegSession
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.Begin,
		&i.End,
		&i.DataCount,
		&i.ExpiredAt,
		&i.Finish,
		&i.DataBitsMap,
	)
	return i, err
}

const getEEGSessionByUID = `-- name: GetEEGSessionByUID :many
SELECT id, uid, begin, end, data_count, expired_at, finish, data_bits_map FROM ` + "`" + `eeg_session` + "`" + ` WHERE uid = ?
`

func (q *Queries) GetEEGSessionByUID(ctx context.Context, uid uint64) ([]EegSession, error) {
	rows, err := q.db.QueryContext(ctx, getEEGSessionByUID, uid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EegSession{}
	for rows.Next() {
		var i EegSession
		if err := rows.Scan(
			&i.ID,
			&i.Uid,
			&i.Begin,
			&i.End,
			&i.DataCount,
			&i.ExpiredAt,
			&i.Finish,
			&i.DataBitsMap,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestEEGSession = `-- name: GetLatestEEGSession :one
SELECT id, uid, begin, end, data_count, expired_at, finish, data_bits_map FROM ` + "`" + `eeg_session` + "`" + ` WHERE id = LAST_INSERT_ID()
`

func (q *Queries) GetLatestEEGSession(ctx context.Context) (EegSession, error) {
	row := q.db.QueryRowContext(ctx, getLatestEEGSession)
	var i EegSession
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.Begin,
		&i.End,
		&i.DataCount,
		&i.ExpiredAt,
		&i.Finish,
		&i.DataBitsMap,
	)
	return i, err
}

const getUnfinishedEEGSession = `-- name: GetUnfinishedEEGSession :many
SELECT id, uid, begin, end, data_count, expired_at, finish, data_bits_map FROM ` + "`" + `eeg_session` + "`" + ` WHERE finish = false
`

func (q *Queries) GetUnfinishedEEGSession(ctx context.Context) ([]EegSession, error) {
	rows, err := q.db.QueryContext(ctx, getUnfinishedEEGSession)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EegSession{}
	for rows.Next() {
		var i EegSession
		if err := rows.Scan(
			&i.ID,
			&i.Uid,
			&i.Begin,
			&i.End,
			&i.DataCount,
			&i.ExpiredAt,
			&i.Finish,
			&i.DataBitsMap,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnfinishedEEGSessionByUID = `-- name: GetUnfinishedEEGSessionByUID :many
SELECT id, uid, begin, end, data_count, expired_at, finish, data_bits_map FROM ` + "`" + `eeg_session` + "`" + ` WHERE uid = ? AND finish = FALSE
`

func (q *Queries) GetUnfinishedEEGSessionByUID(ctx context.Context, uid uint64) ([]EegSession, error) {
	rows, err := q.db.QueryContext(ctx, getUnfinishedEEGSessionByUID, uid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EegSession{}
	for rows.Next() {
		var i EegSession
		if err := rows.Scan(
			&i.ID,
			&i.Uid,
			&i.Begin,
			&i.End,
			&i.DataCount,
			&i.ExpiredAt,
			&i.Finish,
			&i.DataBitsMap,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEEGSession = `-- name: UpdateEEGSession :exec
UPDATE ` + "`" + `eeg_session` + "`" + `
SET
end = COALESCE(?,end),
expired_at = COALESCE(?,expired_at),
finish = COALESCE(?,finish),
data_count = data_count +  COALESCE(?,0),
data_bits_map = COALESCE(?,data_bits_map)
WHERE id = ?
`

type UpdateEEGSessionParams struct {
	End         sql.NullTime   `json:"end"`
	ExpiredAt   sql.NullTime   `json:"expired_at"`
	Finish      sql.NullBool   `json:"finish"`
	DataCount   sql.NullInt32  `json:"data_count"`
	DataBitsMap sql.NullString `json:"data_bits_map"`
	ID          uint64         `json:"id"`
}

func (q *Queries) UpdateEEGSession(ctx context.Context, arg UpdateEEGSessionParams) error {
	_, err := q.db.ExecContext(ctx, updateEEGSession,
		arg.End,
		arg.ExpiredAt,
		arg.Finish,
		arg.DataCount,
		arg.DataBitsMap,
		arg.ID,
	)
	return err
}
